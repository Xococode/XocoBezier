<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Bezier Variable Offsetting (Refinado)</title>
  <link
    href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"
    rel="stylesheet"
  />
  <style>
    :root {
      /* Colores principales */
      --color-primary: #4361ee;
      --color-primary-light: #4895ef;
      --color-secondary: #5057c9;
      --color-accent: #f72585;

      /* Fondos y textos */
      --bg-light: #1a1a1d;
      --text-light: #f8f9fa;
      --text-dark: #e1e1e1;
      --bg-gray: #333;

      /* Curvas y perímetro */
      --curve-center: #9e9e9e;
      --curve-offset: #4895ef;
      --perimeter: #ff00ff;
      --cap-fill: rgba(180,180,180,0.15);

      /* Dimensiones */
      --border-radius: 8px;
      --transition-all: all 0.3s ease;
      --shadow: 0 4px 8px rgba(0,0,0,0.4);

      /* Colores de puntos */
      --dot-p1: #ff8a80;
      --dot-pc: #80d8ff;
      --dot-p2: #b9f6ca;
    }

    *, *::before, *::after {
      box-sizing: border-box;
    }
    html, body {
      margin: 0; padding: 0;
      width: 100%; height: 100%;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: var(--bg-light);
      color: var(--text-dark);
      overflow: hidden;
    }
    canvas {
      display: block;
      width: 100%; height: 100%;
      cursor: default;
    }

    /* Top bar */
    .top-bar {
      position: absolute; top: 0; left: 0; right: 0;
      background: var(--color-primary);
      color: var(--text-light);
      padding: 0.75rem 1rem;
      box-shadow: var(--shadow);
      display: flex; flex-wrap: wrap;
      align-items: center; justify-content: space-between;
      gap: 0.5rem;
    }
    .app-title { font-size: 1.25rem; font-weight: bold; }
    .toggle-buttons { display: flex; flex-wrap: wrap; gap: 0.5rem; }

    /* Botones */
    .btn {
      background: var(--color-secondary);
      color: white;
      border: none;
      padding: 0.5rem 0.75rem;
      border-radius: var(--border-radius);
      cursor: pointer;
      font-size: 0.9rem;
      font-weight: 500;
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
      transition: var(--transition-all);
    }
    .btn:hover    { background: var(--color-primary-light); transform: translateY(-2px); }
    .btn.active   { background: var(--color-accent); }

    /* Paneles laterales */
    .panel {
      position: absolute;
      background: rgba(40,40,45,0.97);
      color: var(--text-light);
      padding: 1rem;
      border-radius: var(--border-radius);
      box-shadow: var(--shadow);
      max-width: calc(100vw - 2rem);
      width: 300px;
      overflow: hidden;
      transition: var(--transition-all);
      z-index: 10;
    }
    .controls-panel { bottom: 1rem; left: 1rem; max-height: calc(100vh - 6rem); overflow-y: auto; }
    .info-panel     { top: 4.5rem; right: 1rem; }
    .panel.collapsed .panel-body { display: none; }

    .panel-header {
      display: flex; justify-content: space-between;
      align-items: center; margin-bottom: 0.5rem;
      border-bottom: 1px solid var(--bg-gray);
    }
    .panel-title { font-size: 1.1rem; color: var(--color-primary-light); }

    .collapse-btn {
      background: none; border: none; cursor: pointer;
      color: var(--color-primary-light); font-size: 1.1rem;
      transition: transform 0.3s ease;
    }
    .panel.collapsed .collapse-btn { transform: rotate(-180deg); }

    /* Sliders */
    .control-row { margin: 0.75rem 0; }
    .slider-label {
      display: flex; justify-content: space-between;
      font-size: 0.85rem; color: #ccc;
      margin-bottom: 0.25rem;
    }
    .slider-label .value { color: var(--color-primary-light); font-weight: bold; }
    .slider-container { height: 1.125rem; display: flex; align-items: center; }
    input[type="range"] {
      -webkit-appearance: none; width: 100%; height: 0.375rem;
      background: var(--bg-gray); border-radius: 3px; outline: none;
      cursor: pointer; transition: var(--transition-all);
    }
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 1.125rem; height: 1.125rem; border-radius: 50%;
      background: var(--color-primary); border: 2px solid #555;
      cursor: pointer; transition: var(--transition-all);
    }
    input[type="range"]::-webkit-slider-thumb:hover {
      background: var(--color-primary-light);
      transform: scale(1.1);
    }

    /* Etiquetas de los puntos */
    .curve-type { display: flex; align-items: center; margin: 0.25rem 0; }
    .curve-dot {
      width: 0.625rem; height: 0.625rem;
      border-radius: 50%; margin-right: 0.5rem;
      border: 1px solid rgba(255,255,255,0.2);
    }
    .dot-p1 { background: var(--dot-p1); }
    .dot-pc { background: var(--dot-pc); }
    .dot-p2 { background: var(--dot-p2); }
    .curve-type span { font-size: 0.9rem; color: var(--text-light); }
    .key-point {
      display: inline-block; width: 1.5rem; font-weight: bold;
      color: var(--color-primary-light);
    }

    /* Responsive */
    @media (max-width: 768px) {
      .panel { width: calc(100vw - 1.5rem); }
      .app-title { font-size: 1.1rem; }
      .btn { padding: 0.4rem 0.6rem; font-size: 0.8rem; }
    }
  </style>
</head>
<body>
  <canvas id="bezierCanvas" aria-label="Canvas de curvas Bézier"></canvas>

  <div class="top-bar">
    <h1 class="app-title">Bezier Variable Offsetting</h1>
    <div class="toggle-buttons" role="group" aria-label="Modos de dibujo">
      <button id="btnControl"  class="btn active" aria-pressed="true">
        <i class="fas fa-vector-square"></i> Controles
      </button>
      <button id="btnPerimeter" class="btn" aria-pressed="false">
        <i class="fas fa-vector-polygon"></i> Perímetro
      </button>
      <button id="btnCaps"      class="btn" aria-pressed="false">
        <i class="fas fa-circle-half-stroke"></i> Terminaciones
      </button>
      <button id="btnVolume"    class="btn" aria-pressed="false">
        <i class="fas fa-fill-drip"></i> Relleno
      </button>
    </div>
  </div>

  <aside class="panel info-panel" id="infoPanel">
    <header class="panel-header">
      <h2 class="panel-title">Info</h2>
      <button class="collapse-btn" id="collapseInfo" aria-expanded="true">
        <i class="fas fa-chevron-up"></i>
      </button>
    </header>
    <div class="panel-body">
      <div class="curve-type">
        <div class="curve-dot dot-p1"></div>
        <span><span class="key-point">P1</span> Punto inicial</span>
      </div>
      <div class="curve-type">
        <div class="curve-dot dot-pc"></div>
        <span><span class="key-point">PC</span> Punto de control</span>
      </div>
      <div class="curve-type">
        <div class="curve-dot dot-p2"></div>
        <span><span class="key-point">P2</span> Punto final</span>
      </div>
      <p style="font-size:0.9rem; line-height:1.4;">
        Arrastra los puntos, ajusta anchuras, curvatura y resolución. Los offsets usan
        la aproximación de G. Suchowolski.
      </p>
    </div>
  </aside>

  <aside class="panel controls-panel" id="controlsPanel">
    <header class="panel-header">
      <h2 class="panel-title">Parámetros</h2>
    </header>
    <div class="panel-body">
      <!-- Control de anchura P1 -->
      <div class="control-row">
        <div class="slider-label">
          <span>Ancho P1</span>
          <span class="value" id="p1-width-value">97</span>
        </div>
        <div class="slider-container">
          <input type="range" id="p1-width" min="1" max="300" step="1" value="97"
                 aria-label="Ancho inicio (P1)"/>
        </div>
      </div>

      <!-- Control de anchura P2 -->
      <div class="control-row">
        <div class="slider-label">
          <span>Ancho P2</span>
          <span class="value" id="p2-width-value">171</span>
        </div>
        <div class="slider-container">
          <input type="range" id="p2-width" min="1" max="300" step="1" value="171"
                 aria-label="Ancho fin (P2)"/>
        </div>
      </div>

      <!-- Control de curvatura -->
      <div class="control-row">
        <div class="slider-label">
          <span>Curvatura</span>
          <span class="value" id="curv-value">50</span>
        </div>
        <div class="slider-container">
          <input type="range" id="curv-slider" min="1" max="100" step="1" value="50"
                 aria-label="Curvatura"/>
        </div>
      </div>

      <!-- Control de resolución -->
      <div class="control-row">
        <div class="slider-label">
          <span>Resolución</span>
          <span class="value" id="res-value">10</span>
        </div>
        <div class="slider-container">
          <input type="range" id="res-slider" min="2" max="50" step="1" value="10"
                 aria-label="Resolución"/>
        </div>
      </div>
    </div>
  </aside>

  <script>
  (() => {
    'use strict';

    // —————————————————————————————————————————————————————————————————————
    // Utilities (Vec2D, MathUtils) con ES6, JSDoc y sin duplicar
    // —————————————————————————————————————————————————————————————————————

    class Vec2D {
      constructor(x=0, y=0) { this.x = x; this.y = y; }
      clone() { return new Vec2D(this.x, this.y); }
      add(v)    { return new Vec2D(this.x + v.x, this.y + v.y); }
      sub(v)    { return new Vec2D(this.x - v.x, this.y - v.y); }
      scale(s)  { return new Vec2D(this.x * s, this.y * s); }
      dot(v)    { return this.x * v.x + this.y * v.y; }
      length()  { return Math.hypot(this.x, this.y); }
      normalize() {
        const len = this.length();
        return len > 1e-9 ? this.scale(1 / len) : new Vec2D();
      }
      perpendicular() { return new Vec2D(-this.y, this.x); }
      static lerp(a, b, t) {
        return new Vec2D(a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t);
      }
    }

    const MathUtils = {
      getPoint(t, p1, pc, p2) {
        const mt = 1 - t;
        return new Vec2D(
          mt*mt*p1.x + 2*mt*t*pc.x + t*t*p2.x,
          mt*mt*p1.y + 2*mt*t*pc.y + t*t*p2.y
        );
      },
      getTangent(t, p1, pc, p2) {
        const mt = 1 - t;
        return new Vec2D(
          2*mt*(pc.x - p1.x) + 2*t*(p2.x - pc.x),
          2*mt*(pc.y - p1.y) + 2*t*(p2.y - pc.y)
        );
      }
    };

    // —————————————————————————————————————————————————————————————————————
    // Clase Dragable para puntos de control
    // —————————————————————————————————————————————————————————————————————

    class Draggable {
      constructor(ctx, pos, colorVar) {
        this.ctx = ctx;
        this.pos = pos;
        this.colorVar = colorVar;
        this.radius = 8;
        this.dragging = false;
      }
      draw() {
        const style = getComputedStyle(document.documentElement);
        const color = style.getPropertyValue(this.colorVar).trim();
        this.ctx.fillStyle = color;
        this.ctx.strokeStyle = 'rgba(255,255,255,0.5)';
        this.ctx.beginPath();
        this.ctx.arc(this.pos.x, this.pos.y, this.radius, 0, Math.PI*2);
        this.ctx.fill(); this.ctx.stroke();
      }
      hit(point) {
        return this.pos.sub(point).length() < this.radius * 2.5;
      }
      start(point) {
        if (!this.hit(point)) return false;
        this.dragging = true;
        this.offset = point.sub(this.pos);
        return true;
      }
      move(point) {
        if (!this.dragging) return;
        this.pos = point.sub(this.offset);
      }
      end() { this.dragging = false; }
    }

    // —————————————————————————————————————————————————————————————————————
    // Variables globales y referencia a canvas/context
    // —————————————————————————————————————————————————————————————————————

    const canvas = document.getElementById('bezierCanvas');
    const ctx    = canvas.getContext('2d');
    const drags  = [];
    let params   = {
      widthA: 97, widthB: 171, curvature: 50, resolution: 10,
      modeControl: true, modePerimeter: false,
      caps: false, fillVolume: false
    };

    // —————————————————————————————————————————————————————————————————————
    // Inicialización: puntos y eventos
    // —————————————————————————————————————————————————————————————————————

    const init = () => {
      resizeCanvas();
      window.addEventListener('resize', debounce(resizeCanvas, 100));
      setupDraggables();
      bindUI();
      requestAnimationFrame(drawLoop);
    };

    const setupDraggables = () => {
      const w = canvas.width, h = canvas.height, o = Math.min(w,h)*0.1;
      const pts = [
        new Vec2D(w*0.25, h*0.5 + o),
        new Vec2D(w*0.5,  h*0.5 - o*1.5),
        new Vec2D(w*0.75, h*0.5 + o)
      ];
      ['--dot-p1','--dot-pc','--dot-p2']
        .forEach((cVar,i) => drags.push(new Draggable(ctx, pts[i], cVar)));
      canvas.addEventListener('pointerdown', onPointerDown);
      window .addEventListener('pointermove', onPointerMove);
      window .addEventListener('pointerup',   onPointerUp);
    };

    // —————————————————————————————————————————————————————————————————————
    // UI: sliders y botones
    // —————————————————————————————————————————————————————————————————————

    function bindUI() {
      const byId = id => document.getElementById(id);
      // Sliders
      [['p1-width','widthA','p1-width-value'],
       ['p2-width','widthB','p2-width-value'],
       ['curv-slider','curvature','curv-value'],
       ['res-slider','resolution','res-value']
      ].forEach(([slider, key, valSpan]) => {
        const s = byId(slider), v = byId(valSpan);
        const onInput = () => {
          params[key] = Number(s.value);
          v.textContent = s.value;
        };
        s.addEventListener('input', onInput);
      });
      // Botones
      const toggleBtn = (id, flagKey) => {
        const btn = byId(id);
        btn.addEventListener('click', () => {
          params[flagKey] = !params[flagKey];
          btn.classList.toggle('active', params[flagKey]);
          btn.setAttribute('aria-pressed', params[flagKey]);
          // for caps/fill, ensure perimeter mode ON
          if ((flagKey==='caps' || flagKey==='fillVolume') && params[flagKey]) {
            params.modePerimeter = true;
            byId('btnPerimeter').classList.add('active');
          }
        });
      };
      toggleBtn('btnControl',   'modeControl');
      toggleBtn('btnPerimeter', 'modePerimeter');
      toggleBtn('btnCaps',      'caps');
      toggleBtn('btnVolume',    'fillVolume');

      // Collapse info
      const infoPanel = byId('infoPanel'), btn = byId('collapseInfo');
      btn.addEventListener('click', () => {
        const collapsed = infoPanel.classList.toggle('collapsed');
        btn.setAttribute('aria-expanded', !collapsed);
      });
    }

    // —————————————————————————————————————————————————————————————————————
    // Eventos de pointer (mouse/touch unificados)
    // —————————————————————————————————————————————————————————————————————

    let activeDrag = null;
    function onPointerDown(e) {
      const pos = getCanvasPos(e);
      for (let d of drags) {
        if (d.start(pos)) { activeDrag = d; break; }
      }
    }
    function onPointerMove(e) {
      if (!activeDrag) return;
      const pos = getCanvasPos(e);
      activeDrag.move(pos);
    }
    function onPointerUp() {
      if (activeDrag) activeDrag.end();
      activeDrag = null;
    }

    const getCanvasPos = e => {
      const rect = canvas.getBoundingClientRect();
      return new Vec2D(
        e.clientX - rect.left,
        e.clientY - rect.top
      );
    };

    // —————————————————————————————————————————————————————————————————————
    // Bucle de dibujo
    // —————————————————————————————————————————————————————————————————————

    function drawLoop() {
      clearCanvas();
      if (drags.length < 3) return;
      const [p1, pc, p2] = drags.map(d => d.pos);

      // Coordenadas, normales y offsets
      const v1 = pc.sub(p1).normalize();
      const v2 = p2.sub(pc).normalize();
      const n1 = v1.perpendicular().scale(params.widthA/2);
      const n2 = v2.perpendicular().scale(params.widthB/2);

      // Segmentos offset (sin división interna para mantenerlo compacto)
      const offA = [{ p1: p1.add(n1),   pc: pc.add(n1).add(n2).scale(0.5),  p2: p2.add(n2) }];
      const offB = [{ p1: p1.sub(n1),   pc: pc.sub(n1).sub(n2).scale(0.5),  p2: p2.sub(n2) }];

      // Modo perímetro
      if (params.modePerimeter) {
        ctx.beginPath();
        drawSegmentsPath(offA, params.resolution);
        drawCaps(p2, offA[0].p2, offB[0].p2, params.caps);
        drawSegmentsReverse(offB, params.resolution);
        drawCaps(p1, offB[0].p1, offA[0].p1, params.caps, true);
        ctx.strokeStyle = 'var(--perimeter)';
        ctx.lineWidth = 2;
        ctx.stroke();
        if (params.fillVolume) {
          ctx.fillStyle = 'var(--perimeter)';
          ctx.fill('evenodd');
        }
      } else {
        // Modo normal: centro + offsets + puntos guía
        ctx.strokeStyle = 'var(--curve-center)'; ctx.lineWidth = 1.5;
        ctx.beginPath(); ctx.moveTo(p1.x,p1.y);
        drawCurve(p1, pc, p2, params.resolution);
        ctx.stroke();

        ctx.strokeStyle = 'var(--curve-offset)'; ctx.lineWidth = 2;
        drawSegmentsPath(offA, params.resolution);
        drawSegmentsPath(offB, params.resolution);

        // Puntos
        drags.forEach(d => d.draw());
      }

      requestAnimationFrame(drawLoop);
    }

    // —————————————————————————————————————————————————————————————————————
    // Helpers de dibujo
    // —————————————————————————————————————————————————————————————————————

    const clearCanvas = () => {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
    };

    function drawCurve(p1, pc, p2, res) {
      for (let i = 1; i <= res; i++) {
        const pt = MathUtils.getPoint(i / res, p1, pc, p2);
        ctx.lineTo(pt.x, pt.y);
      }
    }

    function drawSegmentsPath(segments, res) {
      ctx.beginPath();
      ctx.moveTo(segments[0].p1.x, segments[0].p1.y);
      segments.forEach(seg => drawCurve(seg.p1, seg.pc, seg.p2, res));
      ctx.stroke();
    }

    function drawCaps(center, endA, endB, round, invert=false) {
      if (!round) { ctx.lineTo(endB.x,endB.y); return; }
      const r = Math.hypot(endA.x - center.x, endA.y - center.y);
      const a1 = Math.atan2(endA.y-center.y, endA.x-center.x);
      const a2 = Math.atan2(endB.y-center.y, endB.x-center.x);
      const ccw = invert ? a1 > a2 : a2 > a1;
      ctx.arc(center.x, center.y, r, a1, a2, !ccw);
    }

    // —————————————————————————————————————————————————————————————————————
    // Ajuste de canvas y debounce
    // —————————————————————————————————————————————————————————————————————

    function resizeCanvas() {
      canvas.width  = window.innerWidth;
      canvas.height = window.innerHeight;
    }

    function debounce(fn, ms) {
      let timer = null;
      return (...args) => {
        clearTimeout(timer);
        timer = setTimeout(() => fn(...args), ms);
      };
    }

    // —————————————————————————————————————————————————————————————————————
    // Arranca
    // —————————————————————————————————————————————————————————————————————
    window.addEventListener('load', init);

  })();
  </script>
</body>
</html>
